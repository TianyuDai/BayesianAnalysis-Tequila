{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "bb0d1982",
   "metadata": {},
   "source": [
    "# Closure test of Bayesian analysis"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 3,
||||||| 6127868
   "execution_count": 29,
=======
   "execution_count": 1,
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
   "id": "503f6dc3",
   "metadata": {},
   "outputs": [],
   "source": [
    "# prepare\n",
    "import subprocess\n",
    "from multiprocessing import Pool, cpu_count\n",
    "import os, pickle, math, time\n",
    "\n",
    "import numpy as np\n",
    "from numpy.linalg import inv\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.cm as cm\n",
    "%matplotlib inline\n",
    "import seaborn as sns\n",
    "# sns.set(\"notebook\")\n",
    "sns.color_palette('Set2')\n",
    "import pandas as pd\n",
    "\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.gaussian_process import GaussianProcessRegressor as gpr\n",
    "from sklearn.gaussian_process import kernels as krnl\n",
    "\n",
    "import scipy.stats as st\n",
    "from scipy import optimize\n",
    "from scipy.linalg import lapack\n",
    "\n",
    "from pyDOE import lhs\n",
    "import emcee\n",
    "import h5py\n",
    "\n",
    "FW = 600\n",
    "\n",
    "path = '/home/td115/research/BayesianAnalysis-Tequila'\n",
    "\n",
    "def save_fig(fig_id):\n",
    "    plt.savefig(path+fig_id, format='png', dpi=300)\n",
    "    \n",
    "def hist_1d_2d(X, Y, nameX, nameY):\n",
    "    left, width = 0.1, 0.75\n",
    "    bottom, height = 0.1, 0.75\n",
    "    spacing = 0.005\n",
    "    rect_scatter = [left, bottom, width, height]\n",
    "    rect_histx = [left, bottom + height + spacing, width, 0.15]\n",
    "    rect_histy = [left + width + spacing, bottom, 0.15, height]\n",
    "\n",
    "    fig = plt.figure(figsize=(4, 4))\n",
    "    ax = fig.add_axes(rect_scatter)\n",
    "    ax1 = fig.add_axes(rect_histx, sharex=ax)\n",
    "    ax2 = fig.add_axes(rect_histy, sharey=ax)\n",
    "    ax1.tick_params(axis=\"x\", labelbottom=False)\n",
    "    ax2.tick_params(axis=\"y\", labelleft=False)\n",
    "\n",
    "    ax.scatter(X, Y)\n",
    "    ax1.hist(X, density=True)\n",
    "    ax2.hist(Y, orientation='horizontal', density=True)\n",
    "    ax.set_xlabel(nameX)\n",
    "    ax.set_ylabel(nameY)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8bca9edd",
   "metadata": {},
   "source": [
    "## Gaussian emulator"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 10,
||||||| 6127868
   "execution_count": 55,
=======
   "execution_count": 2,
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
   "id": "11a102be",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Gaussian emulator\n",
    "\n",
    "simulation = np.loadtxt(os.path.join(path, 'data', 'running_coupling', 'output_4obs'))\n",
    "simulation_err = np.loadtxt(os.path.join(path, 'data', 'running_coupling', 'output_err_4obs'))\n",
    "\n",
    "use_NL = True\n",
    "Y_model = np.sqrt(simulation) if use_NL else simulation\n",
    "\n",
    "SS  =  StandardScaler(copy=True)\n",
    "Npc = 4\n",
    "pca = PCA(copy=True, whiten=True, svd_solver='full')\n",
    "# Keep only the first `npc` principal components\n",
    "pc_tf_data = pca.fit_transform(SS.fit_transform(Y_model)) [:,:Npc]\n",
    "\n",
    "# The transformation matrix from PC to Physical space\n",
    "inverse_tf_matrix = pca.components_ * np.sqrt(pca.explained_variance_[:, np.newaxis]) * SS.scale_ \n",
    "inverse_tf_matrix = inverse_tf_matrix[:Npc,:]\n",
    "\n",
    "\n",
    "np.savetxt(path+'/data/inverse_tf_matrix', inverse_tf_matrix)\n",
    "np.savetxt(path+'/data/PCA_transformed_data', pc_tf_data)\n",
    "\n",
<<<<<<< HEAD
    "design = np.loadtxt(path+'/data/running_coupling/lhd_sampling_5d_new_param.txt')\n",
||||||| 6127868
    "design = np.loadtxt(path+'/data/running_coupling/lhd_sampling_5d.txt')\n",
=======
    "design = np.loadtxt(path+'/data/running_coupling/new_param/lhd_sampling_5d.txt')\n",
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
    "# design = design[:32]\n",
    "design_max = np.array([2., 2., 0.6, 3.5, 0.4])\n",
    "design_min = np.array([-0.8, -0.8, 0.16, 1.15, 0.1])\n",
    "design_ptp = design_max - design_min\n",
    "# design_ptp = np.array([1.9, 1.9, 1.9, 0.34, 2., 0.3])"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 11,
||||||| 6127868
   "execution_count": 31,
=======
   "execution_count": 3,
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
   "id": "18a438a2",
   "metadata": {},
   "outputs": [
    {
     "data": {
<<<<<<< HEAD
      "image/png": "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\n",
||||||| 6127868
      "image/png": "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9lakInvkyJEaM2aMunTpUtJ5JEn9+vVTv379rtnHw8OjRAt9AAAAAACKq0hF9uLFi0s6R7ElJCSoZs2aqlatmiIjI/X888+revXq19wmKyvLYtnDw4Mr4AAAAAAAmymT79bo27evlixZori4OL388stKTExUv379lJube83tgoOD5ePjY/7MnDmzlBIDAAAAAMqDG3pPtr3cdddd5n83b95cLVq0UP369ZWQkKAePXoUul1KSoq8vb3Ny1zFBgAAAADYUpm8kv1P9erVk5+fnw4ePHjNft7e3hYfimwAAAAAgC2VySvZ//THH3/o9OnTqlWrlr2jAADgUHJzc3X69GlduHCh0D4hISGlmAgAAOfmkEX22bNnLa5KJycna8+ePfL19ZWvr6+effZZDR06VAEBATp06JAee+wxNWjQQH369LFjagAAHMeOHTs0bdo0JSYmKicnp9B+JpNJly9fLsVkAAA4N4cssnfu3Knu3bubl2NiYiRJUVFRmjt3rn788UctXrxYGRkZCgwMVO/evfXcc89x+zcAAJK2bt2qyMhI89XratWqWcxJAgAASo5DFtndunWTYRiFtq9du7YU0wAAULbExsbqwoULuvfee/XCCy/I39/f3pEAACg3HLLIBgAA1tu2bZsaN26sDz74QCaTyd5xAAAoV5xidnEAAPB/Ll++rFatWlFgAwBgBxTZAAA4mbCwMJ06dcreMQAAKJcosgEAcDIPPPCAvv/+ex06dMjeUQAAKHcosgEAcDIPPPCAhg8frl69emn16tXKzc21dyQAAMoNJj4DAMDJ1KtXT5J05MgRDRw4UG5ubqpVq5ZcXPL/tm4ymbjiDQCADVFkAwDgZI4cOWL+t2EYunTpko4ePVpgXyZHAwDAtiiyAQBwMsnJyfaOAABAuUWRDQCAk6lTp469IwAAUG4x8RkAAAAAADbClWwAAJzY1q1bFR8fr2PHjkmSgoKC1L17d3Xs2NHOyQAAcE4U2QAAOKGjR49qxIgR2rx5s6QrE6BJ/zfRWadOnfTRRx8pJCTEbhkBAHBGFNkAADiZjIwMde/eXcnJyfL09FSfPn1Uv359SdLhw4e1Zs0abdy4UT169NDOnTvl4+Nj58QAADgPimwAAJzM66+/ruTkZN166616//33FRgYaNGempqq+++/X6tXr9brr7+uGTNm2CkpAADOh4nP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ffr0kfR/t29f5e7uLulKMV5cVyc9a9euXYHtO3fulGTdVeziqF+/voYPHy5Jmjx5sv78889r9j958qT2799foplQvlBkA2VIr169NHnyZEnSXXfdpVmzZiknJydfv6SkJPXp08duzyNXrFhRDzzwgCTp0Ucf1YkTJ8xt58+f18MPP6zz588XuO3zzz8v6crkJl9++WW+dsMwtG3bNosi3TAM3XPPPTp27JiioqIUHR0tNzc3LVu2TL6+vnrjjTf0xRdf2PIrAgDKodtuu03t27fX9u3bFR0dXeBz13/99ZfmzZtnVZFqa++++26BxWNqaqq54P3nI1VXJyT7+eefi328q0V2YVeyrx6zsCLclt5++201aNBAycnJuuWWWwq88HDx4kUtWLBArVu3tul7uwFuFwfKmNdee02+vr6aPn26Jk+erOnTpys8PFw1a9bU2bNn9eOPP5pvxbbnFdwZM2Zo48aN2r59uxo1aqTu3bvL09NT33//vS5duqRRo0ZpyZIl+bYbOHCg3nzzTU2ePFmDBg1SgwYN1LhxY/n4+Cg9PV0//PCDTp48qccff9w8Q/mLL76otWvXqmnTpnr33XfN+woJCdGiRYt02223KTo6Wrt27brmZGwAAFyLi4uLVq5cqf79+2vx4sX69NNP1bJlS4WEhOjixYs6fPiw9u7dq9zcXI0ePbrAGchL0/vvv69x48YpNDRUzZo1k7e3t9LT0/X999/r/PnzioyM1KBBgyy2GTp0qOLj43XPPfeod+/eqlatmqQrk6g1btz4mscrapFd0leypSuP2W3atEnDhg1TQkKCOnfurNDQULVo0UJeXl5KS0vT9u3bdfbsWXl7e1u8bhS4URTZQBn01FNPacSIEXrvvfe0fv167d69W5mZmapUqZLq1aun2267TVFRUWrdurXdMlaqVEnx8fF66aWXtHTpUq1du1bVqlVTz5499fzzz2vRokWFbvvII48oMjJSb7/9tuLj4xUXFycXFxcFBASodevW6t+/v3litMTERMXGxsrLy0vLly+Xl5eXxb4GDhyomJgYvf766xo2bJg2btzI89kAAKsFBgZq69atWrRokT755BP9+OOP2r59u3x9fRUYGKiHHnpIgwYNkqenp72j6oUXXtDXX3+trVu3auvWrcrMzFTNmjUVHh6u6OhoDR8+PN8PAQ8//LDOnDmjjz76SKtXrzbPrn7PPfdcs8j+/fffdfr0aQUHBxf6fuqrRXhpFNnSlfdkx8fHa82aNfrvf/+rzZs3Ky4uTjk5OapevboiIiLUv39/jRw5Ur6+vqWSCeWDySirD5QAAAAAAOBgeCYbAAAAAAAbocgGAAAAAMBGKLIBAAAAALARimwAAAAAAGyEIhsAAAAAABuhyAYAAAAAwEYosgEAAAAAsBGKbAAAAAAAbIQiGwAAAAAAG6HIBgAAAADARiiyAQAAAACwEYpsAAAAAABshCIbAAAAAAAb+X+lcfhXK3rnbAAAAABJRU5ErkJggg==\n",
=======
      "image/png": "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8eNKTEw0OxYAAG6PB58BAOCmtm3bpiVLlmjZsmUqKCjQPffcY3YkAADcHkU2AABu5MCBA1q8eLHee+89ZWdnq1u3bnrppZd09913KygoyOx4AAC4vWsqsi9fvqyNGzfq8OHDGjx4sGrVqqWff/5ZVquVARwAABO1atVKN998s5KSknTvvfcqNDTU7EgAAHgUh+/J/vHHH9WmTRv17dtXSUlJOn78uCTppZde0pNPPun0gAAAoOL279+vrVu3atSoUU4rsOfMmaOmTZsqICBAHTt21LZt28ptf/r0aSUlJSk8PFz+/v667rrr9OmnnzolCwAArs7hInvUqFG66aab9O9//1s1atSwre/fv78yMjIc6mvKlCm6+eabVatWLYWEhKhfv37av3+/XZsLFy4oKSlJ9erVU1BQkAYMGKD8/HxHYwMA4BGio6Od2t+yZcuUmpqqtLQ07dq1S23btlVCQoKOHTtWZvuioiLdcccdOnLkiFasWKH9+/frzTffVMOGDZ2aCwAAV+Vwkf2Pf/xD48aNk5+fn936pk2b6qeffnKor8zMTCUlJWnLli1at26dLl26pB49eqiwsNDWJiUlRR999JHef/99ZWZm6ueff9bdd9/taGwAAHANpk+fruHDhysxMVGtW7dWenq6AgMDNX/+/DLbz58/X6dOndLq1avVuXNnNW3aVLfffrvatm1bxckBADCHw/dkl5SUqLi4uNT6f/3rX6pVq5ZDfa1Zs8ZuecGCBQoJCdHOnTt122236cyZM3r77be1ZMkSdevWTZL0zjvv6Prrr9eWLVv0P//zP47GBwAAFVRUVKSdO3dq7NixtnVeXl6Kj4/X5s2by9znww8/VFxcnJKSkvTBBx+oQYMGGjx4sJ5++ml5e3tf9b0KCgrslv39/eXv7++cAwEAoAo5PJPdo0cPzZw507ZssVh07tw5paWl6c477/xDYc6cOSNJqlu3riRp586dunTpkuLj421tWrVqpcaNG191cAcAAM5x4sQJFRcXl7q3OzQ0VHl5eWXu88MPP2jFihUqLi7Wp59+qvHjx2vatGl6/vnny32vyMhIBQcH215Tpkxx2nEAAFCVHJ7JnjZtmhISEtS6dWtduHBBgwcP1sGDB1W/fn2999571xykpKREo0ePVufOnXXjjTdKkvLy8uTn56fatWvbtS1vcJf4NBwAALOU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TZ8+nYehAQBQRSpcZF8ppm+77TatW7dOknTPPfdo1KhRGj58uAYNGqTu3bs79OaFhYVq27at5syZc9U2PXv2VG5uru313nvvOfQeAAB4kh07dqhFixaaMWOGTp06pVOnTmnGjBlq0aKFdu3aZXY8AADcXoXvyY6JidHNN9+sfv366Z577pEk/fWvf5Wvr6++/vprDRgwQOPGjXPozXv16qVevXqV28bf319hYWEO9QsAgKdKSUlRnz599Oabb8rH59dh/vLly3r44Yc1evRobdq0yeSEAAC4twoX2ZmZmXrnnXc0ZcoUvfDCCxowYIAefvhhPfPMM5WZTxs3blRISIjq1Kmjbt266fnnn1e9evXK3aegoMBu2d/fX/7+/pUZEwAAl7Bjxw67AluSfHx8NGbMGN10000mJgMAwDNU+HLxW2+9VfPnz1dubq5effVVHTlyRLfffruuu+46vfTSS8rLy3N6uJ49e2rRokXKyMjQSy+9pMzMTPXq1UvFxcXl7hcZGang4GDba8qUKU7PBgCAK7JarcrJySm1/ujRo6pVq5YJiQAA8CwOf4VXzZo1lZiYqMTERB06dEjvvPOO5syZo/Hjx6tnz5768MMPnRbu3nvvtf3cpk0bxcTEqEWLFtq4cWO5938fPXpUVqvVtswsNgDAUwwcOFAPPfSQ/va3v6lTp06SpK+++kpPPfWUBg0aZHI6AADcn8NF9n+LiorSs88+qyZNmmjs2LH65JNPnJWrTM2bN1f9+vV16NChcotsq9VqV2QDAOAp/va3v8lisWjIkCG6fPmyJMnX11cjR47U1KlTTU4HAID7u+Yie9OmTZo/f77+7//+T15eXvrzn/+shx56yJnZSvnXv/6lkydPKjw8vFLfBwCA6srPz0+zZs3SlClTdPjwYUlSixYtFBgYaHIyAAA8g0NF9s8//6wFCxZowYIFOnTokDp16qTZs2frz3/+s2rWrOnwm587d06HDh2yLWdnZysrK0t169ZV3bp1NWnSJA0YMEBhYWE6fPiwxowZo6ioKCUkJDj8XgAAeJLAwEC1adPG7BgAAHicChfZvXr10hdffKH69etryJAhevDBB9WyZcs/9OY7duxQ165dbcupqamSpKFDh2ru3Lnau3evFi5cqNOnTysiIkI9evTQc889xz3WAAAAAACXVOEi29fXVytWrND//u//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
      "text/plain": [
       "<Figure size 720x288 with 2 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "fig, (ax1, ax2) = plt.subplots(1,2,figsize=(10,4))\n",
    "importance = pca.explained_variance_\n",
    "cumulateive_importance = np.cumsum(importance)/np.sum(importance)\n",
    "idx = np.arange(1,1+len(importance))\n",
    "ax1.bar(idx,importance, alpha=0.5, color='cornflowerblue')\n",
    "ax1.set_xlabel(\"PC index\")\n",
    "ax1.set_ylabel(\"Variance\")\n",
    "# ax1.set_yscale(\"log\")\n",
    "ax2.bar(idx,cumulateive_importance, alpha=0.5, color='cornflowerblue')\n",
    "ax2.set_xlabel(r\"The first $n$ PC\")\n",
    "ax2.set_ylabel(\"Fraction of total variance\")\n",
    "plt.tight_layout()\n",
    "ax1.tick_params(direction=\"in\", which='both')\n",
    "ax2.tick_params(direction=\"in\", which='both')\n",
    "plt.savefig(path+\"/plots/running_coupling/PC_importance_2obs\")"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 12,
||||||| 6127868
   "execution_count": 10,
=======
   "execution_count": 4,
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
   "id": "924edd30",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
<<<<<<< HEAD
      "[0.77746048 0.91318165 0.97328193 0.98438271 0.98718422 0.98873101\n",
      " 0.99001793 0.99103624 0.9919203  0.99276815 0.99350361 0.99417974\n",
      " 0.99482156 0.99542945 0.99598663 0.9964945  0.99691782 0.9973167\n",
      " 0.99769615 0.99805133 0.99830129 0.99854121 0.99874801 0.99894042\n",
      " 0.99912044 0.99926248 0.99939258 0.99950437 0.99960349 0.99969389\n",
      " 0.99976584 0.99982267 0.99986611 0.99990403 0.99993333 0.99995911\n",
      " 0.9999797  0.99999521 1.         1.        ]\n"
||||||| 6127868
      "[0.86770793 0.9659415  0.97737458 0.980997   0.98430652 0.98614879\n",
      " 0.98752043 0.98867652 0.98970544 0.99072568 0.99165556 0.99238764\n",
      " 0.99308044 0.99375161 0.99432959 0.99488089 0.99536956 0.99580364\n",
      " 0.99623167 0.99662053 0.99697897 0.99733106 0.99764541 0.9978947\n",
      " 0.99812463 0.99834675 0.99854545 0.99874157 0.99889828 0.9990495\n",
      " 0.99918622 0.99931266 0.99942506 0.99952122 0.99960673 0.9996762\n",
      " 0.99974011 0.99979562 0.99984137 0.9998781  0.99990941 0.99993435\n",
      " 0.99995483 0.99996954 0.99998362 0.99999467 1.        ]\n"
=======
      "[0.69779203 0.88645334 0.95355582 0.98403559 0.98619477 0.98821056\n",
      " 0.98959443 0.99081906 0.99175254 0.99262712 0.9934485  0.99420272\n",
      " 0.99482612 0.99539828 0.99594155 0.99644937 0.99691673 0.99729396\n",
      " 0.99764002 0.99795654 0.99822802 0.99849129 0.99871699 0.99891559\n",
      " 0.9990875  0.99924762 0.99938118 0.9994944  0.99959241 0.9996801\n",
      " 0.99975669 0.99981092 0.99985968 0.99989774 0.99993493 0.99996351\n",
      " 0.99998656 0.99999482 1.         1.        ]\n"
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
     ]
    }
   ],
   "source": [
    "print(cumulateive_importance)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 13,
||||||| 6127868
   "execution_count": 11,
=======
   "execution_count": 5,
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
   "id": "c59d8f59",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "transformed = SS.fit_transform(Y_model)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 14,
||||||| 6127868
   "execution_count": 12,
=======
   "execution_count": 6,
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
   "id": "73a01b2b",
   "metadata": {},
   "outputs": [
    {
     "data": {
<<<<<<< HEAD
      "image/png": "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\n",
||||||| 6127868
      "image/png": "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\n",
=======
      "image/png": "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
      "text/plain": [
       "<Figure size 288x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.figure(figsize=(4, 4))\n",
    "plt.scatter(pc_tf_data.T[0], pc_tf_data.T[1], label='PCA', color='cornflowerblue', alpha=0.5)\n",
    "plt.scatter(transformed.T[0], transformed.T[1], label='original', color='tomato', alpha=0.5)\n",
    "plt.legend()\n",
    "plt.tick_params(direction=\"in\", which='both')\n",
    "plt.savefig('PCA_orthogonal')"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 15,
||||||| 6127868
   "execution_count": 56,
=======
   "execution_count": 7,
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
   "id": "d048d415",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-----------------\n",
      "Training PC # 1\n",
<<<<<<< HEAD
      "GPR score: 0.996\n",
      "time: 0.081 seconds\n",
||||||| 6127868
      "GPR score: 0.987\n",
      "time: 0.095 seconds\n",
=======
      "GPR score: 0.816\n",
      "time: 0.085 seconds\n",
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
      "-----------------\n",
      "Training PC # 2\n",
<<<<<<< HEAD
      "GPR score: 0.983\n",
      "time: 0.067 seconds\n",
||||||| 6127868
      "GPR score: 0.991\n",
      "time: 0.036 seconds\n",
=======
      "GPR score: 0.353\n",
      "time: 0.060 seconds\n",
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
      "-----------------\n",
      "Training PC # 3\n",
<<<<<<< HEAD
      "GPR score: 0.974\n",
      "time: 0.089 seconds\n"
||||||| 6127868
      "GPR score: 0.872\n",
      "time: 0.036 seconds\n"
=======
      "GPR score: 0.652\n",
      "time: 0.049 seconds\n",
      "-----------------\n",
      "Training PC # 4\n",
      "GPR score: 0.515\n",
      "time: 0.063 seconds\n"
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
<<<<<<< HEAD
      "/home/td115/.local/lib/python3.10/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 4 of parameter k1__k2__length_scale is close to the specified upper bound 30.000000000000004. Increasing the bound and calling fit again may find a better value.\n",
||||||| 6127868
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 3 of parameter k1__k2__length_scale is close to the specified upper bound 105.0. Increasing the bound and calling fit again may find a better value.\n",
=======
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 0 of parameter k1__k2__length_scale is close to the specified upper bound 280.0. Increasing the bound and calling fit again may find a better value.\n",
      "  warnings.warn(\n",
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 3 of parameter k1__k2__length_scale is close to the specified upper bound 235.0. Increasing the bound and calling fit again may find a better value.\n",
      "  warnings.warn(\n",
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 0 of parameter k1__k2__length_scale is close to the specified upper bound 280.0. Increasing the bound and calling fit again may find a better value.\n",
      "  warnings.warn(\n",
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:420: ConvergenceWarning: The optimal value found for dimension 1 of parameter k1__k2__length_scale is close to the specified lower bound 0.5599999999999999. Decreasing the bound and calling fit again may find a better value.\n",
      "  warnings.warn(\n",
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 2 of parameter k1__k2__length_scale is close to the specified upper bound 43.99999999999999. Increasing the bound and calling fit again may find a better value.\n",
      "  warnings.warn(\n",
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 0 of parameter k1__k2__length_scale is close to the specified upper bound 280.0. Increasing the bound and calling fit again may find a better value.\n",
      "  warnings.warn(\n",
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 2 of parameter k1__k2__length_scale is close to the specified upper bound 43.99999999999999. Increasing the bound and calling fit again may find a better value.\n",
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
      "  warnings.warn(\n",
<<<<<<< HEAD
      "/home/td115/.local/lib/python3.10/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 2 of parameter k1__k2__length_scale is close to the specified upper bound 43.99999999999999. Increasing the bound and calling fit again may find a better value.\n",
||||||| 6127868
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 0 of parameter k1__k2__length_scale is close to the specified upper bound 290.0. Increasing the bound and calling fit again may find a better value.\n",
=======
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 0 of parameter k1__k2__length_scale is close to the specified upper bound 280.0. Increasing the bound and calling fit again may find a better value.\n",
      "  warnings.warn(\n",
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 1 of parameter k1__k2__length_scale is close to the specified upper bound 280.0. Increasing the bound and calling fit again may find a better value.\n",
      "  warnings.warn(\n",
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:430: ConvergenceWarning: The optimal value found for dimension 2 of parameter k1__k2__length_scale is close to the specified upper bound 43.99999999999999. Increasing the bound and calling fit again may find a better value.\n",
      "  warnings.warn(\n",
      "/home/tianyu/.local/lib/python3.8/site-packages/sklearn/gaussian_process/kernels.py:420: ConvergenceWarning: The optimal value found for dimension 3 of parameter k1__k2__length_scale is close to the specified lower bound 0.47000000000000003. Decreasing the bound and calling fit again may find a better value.\n",
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
      "  warnings.warn(\n"
     ]
    }
   ],
   "source": [
    "EMU = path+'/data/running_coupling/emulators.dat'\n",
    "Emulators=[]\n",
    "for i in range(0,Npc):\n",
    "    start_time = time.time()\n",
    "    kernel=1*krnl.RBF(length_scale=design_ptp,\n",
    "                          length_scale_bounds=np.outer(design_ptp, (1./5, 1e2))) + krnl.WhiteKernel(noise_level=.01, \n",
    "                                  noise_level_bounds=(1e-4, 1e4))\n",
    "    print(\"-----------------\")\n",
    "    print(\"Training PC #\",i+1)\n",
    "    GPR=gpr(kernel=kernel,n_restarts_optimizer=0)\n",
    "    GPR.fit(design, pc_tf_data[:,i].reshape(-1,1))\n",
    "    print('GPR score: {:1.3f}'.format(GPR.score(design,pc_tf_data[:,i])) )\n",
    "    print(\"time: {:1.3f} seconds\".format(time.time() - start_time))\n",
    "    Emulators.append(GPR)\n",
    "    \n",
    "with open(EMU, \"wb\") as f:\n",
    "    pickle.dump(Emulators,f)"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 16,
||||||| 6127868
   "execution_count": 14,
=======
   "execution_count": null,
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
   "id": "1bc0f9ae",
   "metadata": {},
   "outputs": [],
   "source": [
    "Xdim = 5\n",
    "use_NL = True\n",
    "def predict_observables(model_parameters, diag_std=False):\n",
    "    \"\"\"Predicts the observables for any model parameter value using the trained emulators.\n",
    "    \n",
    "    Parameters\n",
    "    ----------\n",
    "    Theta_input : Model parameter values.\n",
    "    Return\n",
    "    ------\n",
    "    Mean value and full error covaraiance matrix of the prediction is returened. \"\"\"\n",
    "\n",
    "    mean=[]\n",
    "    variance=[]\n",
    "    theta=np.array(model_parameters).flatten()\n",
    "    if len(theta)!=Xdim:\n",
    "        raise TypeError('The input model_parameters array does not have the right dimensions')\n",
    "    else: \n",
    "        theta=np.array(theta).reshape(1,Xdim)\n",
    "        for i in range(Npc):\n",
    "            mn,std=Emulators[i].predict(theta, return_std=True)\n",
    "            mean.append(mn)\n",
    "            variance.append(std**2)\n",
    "    mean=np.array(mean).reshape(1,-1)\n",
    "    inverse_transformed_mean = mean@inverse_tf_matrix + np.array(SS.mean_).reshape(1,-1)    \n",
    "    variance_matrix = np.diag(np.array(variance).flatten())\n",
    "    inverse_transformed_variance = np.einsum('ik,kl,lj-> ij', inverse_tf_matrix.T, variance_matrix, inverse_tf_matrix, \n",
    "                                             optimize=False)\n",
    "    if use_NL:\n",
    "        inverse_transformed_mean = inverse_transformed_mean**2\n",
    "        inverse_transformed_variance *= np.outer(2.*inverse_transformed_mean[0]**.5, \n",
    "                                                 2.*inverse_transformed_mean[0]**.5)\n",
    "    if diag_std:\n",
    "        return inverse_transformed_mean[0], np.sqrt(np.diag(inverse_transformed_variance))\n",
    "    else:\n",
    "        return inverse_transformed_mean[0], inverse_transformed_variance\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
<<<<<<< HEAD
   "execution_count": 17,
||||||| 6127868
   "execution_count": 15,
=======
   "execution_count": null,
>>>>>>> f3eefe9ee346790e60ffcf780c76b9ffdf5dde5d
   "id": "933d087e",
   "metadata": {},
   "outputs": [],
   "source": [
    "X_validation = np.array([[0, 0, 0.3, 1.6, 0.25]])\n",
    "\n",
    "# Next, get the emulator prediction and uncertainty\n",
    "A = np.array([predict_observables(it, diag_std=True) for it in X_validation])\n",
    "Y_predicted = A[:,0,:]\n",
    "Y_std = A[:,1,:]\n",
    "np.savetxt(path+'/data/running_coupling/data_predicted', Y_predicted)\n",
    "np.savetxt(path+'/data/running_coupling/data_predicted_err', Y_std)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fe161fe4",
   "metadata": {},
   "outputs": [],
   "source": [
    "pT1 = np.array([8.25, 8.75, 9.25, 9.75, 11, 13, 15, 17, 19])\n",
    "Nc1 = 9\n",
    "pT3 = np.array([10.75, 12.35, 14.15, 16.2, 18.6, 21.35, 24.45, 28.05, 33.85, 42.6, 53.65, 67.55, 85.05, 106.9, 134.5])\n",
    "Nc2 = 9 + Nc1\n",
    "pT2 = np.array([8.25, 8.75, 9.25, 9.75, 11, 13, 15, 17, 19])\n",
    "Nc3 = 15 + Nc2\n",
    "pT4 = np.array([10.75, 12.35, 14.15, 16.2, 18.6, 21.35, 24.45, 28.05, 33.85, 42.6, 53.65, 67.55, 85.05, 106.9])\n",
    "Nc4 = 14 + Nc3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cf7ec7d1",
   "metadata": {},
   "outputs": [],
   "source": [
    "Y_validation = np.array([np.loadtxt(path+'/data/running_coupling/data_val_4obs')])\n",
    "Y_validation_err = np.array([np.loadtxt(path+'/data/running_coupling/data_val_err_4obs')])\n",
    "print(Y_validation.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "af7550df",
   "metadata": {},
   "outputs": [],
   "source": [
    "param_samp = np.array([[-0.8, 0., 2.], [-0.8, 0., 2.], [0.16, 0.3, 0.6], [1.15, 1.6, 3.5], [0.1, 0.25, 0.4]])\n",
    "ParameterLabels = ['$\\\\beta_1$', '$\\\\beta_2$', '$T^*$', '$Q_0$', '$\\\\alpha^{inel}_{s, hard}$']\n",
    "colors = ['r', 'b', 'g']\n",
    "\n",
    "fig, axes = plt.subplots(5,4, figsize=(16,16))\n",
    "fig.subplots_adjust(hspace=0, wspace=0)\n",
    "labels = r\"$R_{AA}$\"\n",
    "\n",
    "for i, color in enumerate(colors): \n",
    "    X_validation = np.array([param_samp.T[1]])\n",
    "\n",
    "    \n",
    "    for j, param_label in enumerate(ParameterLabels): \n",
    "        X_validation[0, j] = param_samp[j, i]\n",
    "        A = np.array([predict_observables(it, diag_std=True) for it in X_validation])\n",
    "        Y_predicted = A[:,0,:]\n",
    "        Y_std = A[:,1,:]\n",
    "        for k, (mean, std) in enumerate(zip(Y_predicted, Y_std)):\n",
    "            label = param_label+'=%.2f' %param_samp[j, i]\n",
    "            axes[j, 0].fill_between(pT1,mean[:Nc1]-std[:Nc1],mean[:Nc1]+std[:Nc1],color=color,alpha=.2, label=label)\n",
    "        for k, (mean, std) in enumerate(zip(Y_predicted, Y_std)):\n",
    "            label = param_label+'=%.2f' %param_samp[j, i]\n",
    "            axes[j, 1].fill_between(pT2,mean[Nc1:Nc2]-std[Nc1:Nc2],mean[Nc1:Nc2]+std[Nc1:Nc2],color=color,alpha=.2, label=label)\n",
    "        for k, (mean, std) in enumerate(zip(Y_predicted, Y_std)):\n",
    "            label = param_label+'=%.2f' %param_samp[j, i]\n",
    "            axes[j, 2].fill_between(pT3,mean[Nc2:Nc3]-std[Nc2:Nc3],mean[Nc2:Nc3]+std[Nc2:Nc3],color=color,alpha=.2, label=label)\n",
    "        for k, (mean, std) in enumerate(zip(Y_predicted, Y_std)):\n",
    "            label = param_label+'=%.2f' %param_samp[j, i]\n",
    "            axes[j, 3].fill_between(pT4,mean[Nc3:Nc4]-std[Nc3:Nc4],mean[Nc3:Nc4]+std[Nc3:Nc4],color=color,alpha=.2, label=label)\n",
    "            \n",
    "        # label = 'Model calc.' if i == 0 else ''\n",
    "        axes[j, 0].errorbar(pT1, Y_validation[0][:Nc1], Y_validation_err[0][:Nc1], color='black')\n",
    "        axes[j, 1].errorbar(pT2, Y_validation[0][Nc1:Nc2], Y_validation_err[0][Nc1:Nc2], color='black')\n",
    "        axes[j, 2].errorbar(pT3, Y_validation[0][Nc2:Nc3], Y_validation_err[0][Nc2:Nc3], color='black')\n",
    "        axes[j, 3].errorbar(pT4, Y_validation[0][Nc3:Nc4], Y_validation_err[0][Nc3:Nc4], color='black')\n",
    "        # axes[j, 0].set_xlabel(\"$p_T$ (GeV)\")\n",
    "        axes[j, 0].set_ylabel(labels)\n",
    "        axes[j, 0].legend()\n",
    "        axes[j, 0].set_ylim(0, 1.5)\n",
    "        axes[j, 0].set_xlim(8.25, 19)\n",
    "        # axes[j, 1].set_xlabel(\"$p_T$ (GeV)\")\n",
    "        # axes[j, 1].set_ylabel(labels)\n",
    "        axes[j, 1].legend()\n",
    "        axes[j, 1].set_ylim(0, 1.5)\n",
    "        axes[j, 1].set_xlim(8.25, 19)\n",
    "        # axes[j, 2].set_xlabel(\"$p_T$ (GeV)\")\n",
    "        # axes[j, 2].set_ylabel(labels)\n",
    "        axes[j, 2].legend()\n",
    "        axes[j, 2].set_ylim(0, 1.5)\n",
    "        axes[j, 2].set_xlim(10.75, 106.9)\n",
    "        # axes[j, 3].set_xlabel(\"$p_T$ (GeV)\")\n",
    "        # axes[j, 3].set_ylabel(labels)\n",
    "        axes[j, 3].legend()\n",
    "        axes[j, 3].set_ylim(0, 1.5)\n",
    "        axes[j, 3].set_xlim(10.75, 106.9)\n",
    "        # axes[j, 0].tick_params(axis='y', which='both', labelleft=False)\n",
    "        axes[j, 1].tick_params(axis='y', which='both', labelleft=False)\n",
    "        axes[j, 2].tick_params(axis='y', which='both', labelleft=False)\n",
    "        axes[j, 3].tick_params(axis='y', which='both', labelleft=False)\n",
    "        axes[j, 0].tick_params(direction=\"in\", which='both')\n",
    "        axes[j, 1].tick_params(direction=\"in\", which='both')\n",
    "        axes[j, 2].tick_params(direction=\"in\", which='both')\n",
    "        axes[j, 3].tick_params(direction=\"in\", which='both')\n",
    "axes[4, 0].set_xlabel(\"$p_T$ (GeV)\")\n",
    "axes[4, 1].set_xlabel(\"$p_T$ (GeV)\")\n",
    "axes[4, 2].set_xlabel(\"$p_T$ (GeV)\")\n",
    "axes[4, 3].set_xlabel(\"$p_T$ (GeV)\")\n",
    "\n",
    "\n",
    "# titles = r\"centrality 40-50%\", r\"centrality 40-50%\"\n",
    "# titles = r\"Au+Au 200GeV, centrality 0-10%\"\n",
    "# for ax, label, title in zip(axes, labels, titles):\n",
    "# axes.set_xlabel(\"$p_T$ (GeV)\")\n",
    "# axes.set_ylabel(labels)\n",
    "# axes.legend()\n",
    "# axes.set_ylim(0, 0.5)\n",
    "axes[0, 0].set_title(r\"Au+Au 200GeV, centrality 0-10%\")\n",
    "axes[0, 1].set_title(r\"Pb+Pb 2760GeV, centrality 0-5%\")\n",
    "axes[0, 2].set_title(r\"Au+Au 200GeV, centrality 20-30%\")\n",
    "axes[0, 3].set_title(r\"Pb+Pb 2760GeV, centrality 30-40%\")\n",
    "\n",
    "# plt.tight_layout(True)\n",
    "plt.savefig(path+\"/plots/running_coupling/Emulator_validation_2pca\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "52788eed",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Emulator validation\n",
    "np.random.seed(9)\n",
    "# X_validation = design_min + np.random.rand(2, Xdim)*design_ptp\n",
    "# X_validation = np.array([design[0]])\n",
    "# X_validation = np.array([design[0]])\n",
    "\n",
    "# Next, get the emulator prediction and uncertainty\n",
    "X_validation = np.array([[0, 0, 0.3, 1.6, 0.25]])\n",
    "A = np.array([predict_observables(it, diag_std=True) for it in X_validation])\n",
    "Y_predicted = A[:,0,:]\n",
    "Y_std = A[:,1,:]\n",
    "# print(Y_predicted.shape)\n",
    "\n",
    "\n",
    "# Model calculation at these two points\n",
    "# Y_validation = np.array([np.concatenate(ToyModel(param)) for param in X_validation])\n",
    "# print(Y_validation.shape)\n",
    "# Y_validation = np.array([simulation[0]])\n",
    "Y_validation = np.array([np.loadtxt(path+'/data/running_coupling/data_val_4obs')])\n",
    "Y_validation_err = np.array([np.loadtxt(path+'/data/running_coupling/data_val_err_4obs')])\n",
    "# Y_validation_err = np.array([simulation_err[0]])\n",
    "\n",
    "labels = r\"$R_{AA}^{h^\\pm}$\"\n",
    "\n",
    "# plot the prediction + uncertainty band with the true model caluclation\n",
    "fig, axes = plt.subplots(2,2, figsize=(8,5))\n",
    "fig.subplots_adjust(hspace=0, wspace=0)\n",
    "for i, (mean, std) in enumerate(zip(Y_predicted, Y_std)):\n",
    "    label = 'GP emulated' if i==0 else''\n",
    "    axes[0, 0].fill_between(pT1,mean[:Nc1]-std[:Nc1],mean[:Nc1]+std[:Nc1],color='tomato',alpha=.5, label=label)\n",
    "    axes[1, 0].fill_between(pT2,mean[Nc1:Nc2]-std[Nc1:Nc2],mean[Nc1:Nc2]+std[Nc1:Nc2],color='tomato',alpha=.5, label=label)\n",
    "    axes[0, 1].fill_between(pT3,mean[Nc2:Nc3]-std[Nc2:Nc3],mean[Nc2:Nc3]+std[Nc2:Nc3],color='tomato',alpha=.5, label=label)\n",
    "    axes[1, 1].fill_between(pT4,mean[Nc3:Nc4]-std[Nc3:Nc4],mean[Nc3:Nc4]+std[Nc3:Nc4],color='tomato',alpha=.5, label=label)\n",
    "    # axes[1].fill_between(pT,mean[Nc:]-std[Nc:],mean[Nc:]+std[Nc:],color='r',alpha=.5, label=label)\n",
    "for i, ym, ym_err in zip(range(len(Y_validation)), Y_validation, Y_validation_err):\n",
    "    label = 'Model calc.' if i==0 else''\n",
    "    axes[0, 0].errorbar(pT1, ym[:Nc1], yerr=ym_err[:Nc1], label=label)\n",
    "    axes[1, 0].errorbar(pT2, ym[Nc1:Nc2], yerr=ym_err[Nc1:Nc2], label=label)\n",
    "    axes[0, 1].errorbar(pT3, ym[Nc2:Nc3], yerr=ym_err[Nc2:Nc3], label=label)\n",
    "    axes[1, 1].errorbar(pT4, ym[Nc3:Nc4], yerr=ym_err[Nc3:Nc4], label=label)\n",
    "    \n",
    "    # axes[1].errorbar(pT, ym[Nc:], yerr=ym_err[Nc:], label=label)\n",
    "    # axes[0, 0].set_xlabel(\"$p_T$ (GeV)\")\n",
    "    axes[0, 0].set_ylabel(labels)\n",
    "    # axes[0, 0].legend()\n",
    "    axes[0, 0].set_ylim(0, 1.1)\n",
    "    axes[0, 0].set_xlim(8.25, 19)\n",
    "    axes[0, 0].text(9, 0.9, 'Au+Au 200GeV, 0-10% centrality')\n",
    "    axes[1, 0].set_ylabel(labels)\n",
    "    # axes[1, 0].legend()\n",
    "    axes[1, 0].set_ylim(0, 1.1)\n",
    "    axes[1, 0].set_xlim(8.25, 19)\n",
    "    axes[1, 0].set_xlabel(\"$p_T$ (GeV)\")\n",
    "    axes[1, 0].text(9, 0.9, 'Au+Au 200GeV, 20-30% centrality')\n",
    "    # axes[0, 1].set_ylabel(labels)\n",
    "    # axes[0, 1].legend()\n",
    "    axes[0, 1].set_ylim(0, 1.1)\n",
    "    axes[0, 1].set_xlim(10, 106.5)\n",
    "    axes[0, 1].text(15, 0.9, 'Pb+Pb 2760GeV, 0-5% centrality')\n",
    "    # axes[0, 0].set_ylabel(labels)\n",
    "    axes[1, 1].legend(loc='lower right')\n",
    "    axes[1, 1].set_ylim(0, 1.1)\n",
    "    axes[1, 1].set_xlim(10, 106.5)\n",
    "    axes[1, 1].text(15, 0.9, 'Pb+Pb 2760GeV, 30-40% centrality')\n",
    "    axes[1, 1].set_xlabel(\"$p_T$ (GeV)\")\n",
    "    axes[0, 0].tick_params(direction=\"in\", which='both')\n",
    "    axes[1, 0].tick_params(direction=\"in\", which='both')\n",
    "    axes[0, 1].tick_params(direction=\"in\", which='both')\n",
    "    axes[1, 1].tick_params(direction=\"in\", which='both')\n",
    "    axes[0, 1].tick_params(axis='y', which='both', labelleft=False)\n",
    "    axes[1, 1].tick_params(axis='y', which='both', labelleft=False)\n",
    "\n",
    "\n",
    "# Add labels\n",
    "# labels = r\"$R_{AA}$\", r\"$R_{AA}$\", r\"$\"\n",
    "\n",
    "# titles = r\"centrality 40-50%\", r\"centrality 40-50%\"\n",
    "titles = r\"centrality 0-10%\"\n",
    "# for ax, label, title in zip(axes, labels, titles):\n",
    "\n",
    "# axes.set_title(titles)\n",
    "# plt.tight_layout(True)\n",
    "plt.savefig(path+\"/plots/running_coupling/Emulator_validation_test\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "91a22cb1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# design = np.loadtxt(path+'/data/running_coupling/lhd_sampling_5d.txt')\n",
    "x = np.arange(0., 1.5, 0.001)\n",
    "\n",
    "predicted_combine = []\n",
    "data_combine = []\n",
    "size_list = [9, 9, 15, 14]\n",
    "Nc_list = [0, Nc1, Nc2, Nc3, Nc4]\n",
    "lim_list = [(0.02, 0.8), (0.15, 1), (0.05, 1.1), (0.32, 1.5)]\n",
    "# plt.figure(figsize=(6, 6))\n",
    "label_list = ['$R_{AA}^{h^{\\pm}}$, Au+Au 200GeV, 0-10%', '$R_{AA}^{h^{\\pm}}$, Au+Au 200GeV, 20-30%', '$R_{AA}^{h^{\\pm}}$, Pb+Pb 2760GeV, 0-5%', '$R_{AA}^{h^{\\pm}}$, Pb+Pb 2760GeV, 30-40%']\n",
    "\n",
    "fig, axes = plt.subplots(2,2, figsize=(12, 12),dpi=500)\n",
    "\n",
    "for i in range(len(design)): \n",
    "    design_new = np.concatenate((design[:i], design[i+1:]), axis=0)\n",
    "    Y_model_new = np.concatenate((Y_model[:i], Y_model[i+1:]), axis=0)\n",
    "    \n",
    "    Emulators=[]\n",
    "    pc_tf_data_new = pca.fit_transform(SS.fit_transform(Y_model_new)) [:,:Npc]\n",
    "    for k in range(Npc):\n",
    "        kernel=1*krnl.RBF(length_scale=design_ptp,\n",
    "                          length_scale_bounds=np.outer(design_ptp, (1./5, 1e2))) + krnl.WhiteKernel(noise_level=.01, \n",
    "                                  noise_level_bounds=(1e-4, 1e4))\n",
    "        GPR=gpr(kernel=kernel,n_restarts_optimizer=0)\n",
    "        GPR.fit(design_new, pc_tf_data_new[:,k].reshape(-1,1))\n",
    "        Emulators.append(GPR)\n",
    "        \n",
    "        \n",
    "    mean=[]\n",
    "    theta=np.array(design[i]).flatten()\n",
    "    theta=np.array(theta).reshape(1,Xdim)\n",
    "    for k in range(Npc):\n",
    "        mn=Emulators[k].predict(theta)\n",
    "        mean.append(mn)\n",
    "    mean=np.array(mean).reshape(1,-1)\n",
    "    inverse_transformed_mean = mean@inverse_tf_matrix + np.array(SS.mean_).reshape(1,-1)\n",
    "    inverse_transformed_mean = inverse_transformed_mean**2\n",
    "    A = inverse_transformed_mean[0]\n",
    "    Y_predicted = [A]\n",
    "    \"\"\"\n",
    "    A = np.array([predict_observables(it, diag_std=True) for it in [design[i]]])\n",
    "    Y_predicted = A[:,0,:]\n",
    "    Y_std = A[:,1,:]\n",
    "    # kernel=1*krnl.RBF(length_scale=design_ptp, length_scale_bounds=np.outer(design_ptp, (1./5, 1e2))) + krnl.WhiteKernel(noise_level=.01, noise_level_bounds=(1e-4, 1e4))\n",
    "    # GPR=gpr(kernel=kernel,n_restarts_optimizer=0)\n",
    "    # GPR.fit(design_new, Y_model_new)\n",
    "    # Y_predicted, Y_std = GPR.predict([design[i]], return_std=True)\n",
    "    \"\"\"\n",
    "    predicted_combine.append(Y_predicted[0])\n",
    "    data_combine.append(Y_model[i]**2)\n",
    "    for j, ax, size in zip(range(4), axes.flat, size_list): \n",
    "        t = np.arange(size)\n",
    "        ax.scatter(Y_model[i][Nc_list[j]:Nc_list[j+1]]**2, Y_predicted[0][Nc_list[j]:Nc_list[j+1]], c=t, alpha=0.5, cmap=cm.twilight_shifted)\n",
    "        ax.plot(x, x, color='black')\n",
    "        ax.tick_params(direction=\"in\", which='both')\n",
    "        ax.set_xlim(lim_list[j])\n",
    "        ax.set_ylim(lim_list[j])\n",
    "        ax.text(lim_list[j][0]+0.05, lim_list[j][1]-0.1, label_list[j])\n",
    "        ax.set_xlabel('model calculation')\n",
    "        ax.set_ylabel('emulator prediction')\n",
    "plt.savefig(path+'/plots/running_coupling/model-emulator')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0d7e8014",
   "metadata": {},
   "outputs": [],
   "source": [
    "predicted_combine = np.array(predicted_combine)\n",
    "data_combine = np.array(data_combine)\n",
    "print(data_combine.shape)\n",
    "diff_combine_1 = []\n",
    "diff_combine_2 = []\n",
    "diff_combine_3 = []\n",
    "diff_combine_4 = []\n",
    "\n",
    "for i in range(len(predicted_combine)): \n",
    "    for j in range(Nc1): \n",
    "        diff_combine_1.append((predicted_combine[i, j] - data_combine[i, j]) / data_combine[i, j])\n",
    "    for j in range(Nc1, Nc2): \n",
    "        diff_combine_2.append((predicted_combine[i, j] - data_combine[i, j]) / data_combine[i, j])\n",
    "    for j in range(Nc2, Nc3): \n",
    "        diff_combine_3.append((predicted_combine[i, j] - data_combine[i, j]) / data_combine[i, j])\n",
    "    for j in range(Nc3, Nc4): \n",
    "        diff_combine_4.append((predicted_combine[i, j] - data_combine[i, j]) / data_combine[i, j])\n",
    "\n",
    "bins = np.arange(-0.1, 0.1, 0.02)\n",
    "\n",
    "plt.figure(figsize=(7, 5))\n",
    "plt.hist(diff_combine_1, bins=20, histtype='step', color=sns.color_palette(\"Set2\")[0], label='$R_{AA}^{h^{\\pm}}$, Au+Au, 0-10%', density=True)\n",
    "plt.hist(diff_combine_2, bins=20, histtype='step', color=sns.color_palette(\"Set2\")[1], label='$R_{AA}^{h^{\\pm}}$, Au+Au, 20-30%', density=True)\n",
    "plt.hist(diff_combine_3, bins=20, histtype='step', color=sns.color_palette(\"Set2\")[2], label='$R_{AA}^{h^{\\pm}}$, Pb+Pb, 0-5%', density=True)\n",
    "plt.hist(diff_combine_4, bins=20, histtype='step', color=sns.color_palette(\"Set2\")[3], label='$R_{AA}^{h^{\\pm}}$, Pb+Pb, 30-40%', density=True)\n",
    "plt.axvline(x=0., color='k')\n",
    "plt.xlim(-0.5, 0.5)\n",
    "plt.legend()\n",
    "plt.xlabel('(emulator - model) / model')\n",
    "plt.tick_params(direction=\"in\", which='both')\n",
    "plt.savefig(path+'/plots/running_coupling/emulator_dist')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4f5eb164",
   "metadata": {},
   "outputs": [],
   "source": [
    "ParameterLabels = ['$\\\\beta_1$', '$\\\\beta_2$', '$T^*$', '$Q_0$', '$g^{inel}_{hard}$']\n",
    "ranges = np.array([[-0.8, 2], [-0.8, 2], [0.16, 0.6], [1.15, 3.5], [0.1, 0.4]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a87c58db",
   "metadata": {},
   "outputs": [],
   "source": [
    "def log_prior(model_parameters):\n",
    "    \"\"\"Evaluvate the prior at model prameter values. \n",
    "    If all parameters are inside bounds function will return 0 otherwise -inf\"\"\"\n",
    "    X = np.array(model_parameters).reshape(1,-1)\n",
    "    lower = np.all(X >= design_min)\n",
    "    upper = np.all(X <= design_max)\n",
    "    if (lower and upper):\n",
    "        lp=0\n",
    "    # lp = np.log(st.beta.pdf(X,5,1,dsgn_min_ut.reshape(1,-1),(dsgn_max_ut-dsgn_min_ut).reshape(1,-1))).sum()\n",
    "    else:\n",
    "        lp = -np.inf\n",
    "    return lp\n",
    "\n",
    "def mvn_loglike(y, cov):\n",
    "    \"\"\"\n",
    "    Evaluate the multivariate-normal log-likelihood for difference vector `y`\n",
    "    and covariance matrix `cov`:\n",
    "\n",
    "        log_p = -1/2*[(y^T).(C^-1).y + log(det(C))] + const.\n",
    "\n",
    "    The likelihood is NOT NORMALIZED, since this does not affect MCMC.  The\n",
    "    normalization const = -n/2*log(2*pi), where n is the dimensionality.\n",
    "\n",
    "    Arguments `y` and `cov` MUST be np.arrays with dtype == float64 and shapes\n",
    "    (n) and (n, n), respectively.  These requirements are NOT CHECKED.\n",
    "\n",
    "    The calculation follows algorithm 2.1 in Rasmussen and Williams (Gaussian\n",
    "    Processes for Machine Learning).\n",
    "\n",
    "    \"\"\"\n",
    "    # Compute the Cholesky decomposition of the covariance.\n",
    "    # Use bare LAPACK function to avoid scipy.linalg wrapper overhead.\n",
    "    L, info = lapack.dpotrf(cov, clean=False)\n",
    "\n",
    "    if info < 0:\n",
    "        raise ValueError(\n",
    "            'lapack dpotrf error: '\n",
    "            'the {}-th argument had an illegal value'.format(-info)\n",
    "        )\n",
    "    elif info < 0:\n",
    "        raise np.linalg.LinAlgError(\n",
    "            'lapack dpotrf error: '\n",
    "            'the leading minor of order {} is not positive definite'\n",
    "            .format(info)\n",
    "        )\n",
    "\n",
    "    # Solve for alpha = cov^-1.y using the Cholesky decomp.\n",
    "    alpha, info = lapack.dpotrs(L, y)\n",
    "\n",
    "    if info != 0:\n",
    "        raise ValueError(\n",
    "            'lapack dpotrs error: '\n",
    "            'the {}-th argument had an illegal value'.format(-info)\n",
    "         )\n",
    "\n",
    "    if np.all(L.diagonal()>0):\n",
    "        return -.5*np.dot(y, alpha) - np.log(L.diagonal()).sum()\n",
    "    else:\n",
    "        return -.5*np.dot(y, alpha) - np.log(np.abs(L.diagonal())).sum()\n",
    "        print(L.diagonal())\n",
    "        raise ValueError(\n",
    "            'L has negative values on diagonal {}'.format(L.diagonal())\n",
    "        )\n",
    "\n",
    "def log_posterior(model_parameters):\n",
    "    model_parameters = np.array([model_parameters[0], model_parameters[1], model_parameters[2], 1.75, model_parameters[3]])\n",
    "    mn, var = predict_observables(model_parameters)\n",
    "    delta_y = mn - y_exp\n",
    "    delta_y = delta_y.flatten()   \n",
    "    total_var = var + y_exp_variance\n",
    "    return log_prior(model_parameters) + mvn_loglike(delta_y,total_var)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b7f691a7",
   "metadata": {},
   "source": [
    "# Closure Test"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f744017b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# validate with true values\n",
    "# y_exp = np.loadtxt(path+'/data/true_RAA')\n",
    "# y_exp_err = np.loadtxt(path+'/data/true_RAA_err')\n",
    "# y_exp_variance = np.diag(y_exp_err**2)\n",
    "y_exp = np.loadtxt(path+'/data/running_coupling/data_val_4obs')\n",
    "y_exp_err = np.loadtxt(path+'/data/running_coupling/data_val_err_4obs')\n",
    "y_exp_variance = np.diag(y_exp_err**2)\n",
    "\n",
    "# print(y_err.shape)\n",
    "# y_exp = simulation[7]\n",
    "# y_err = np.loadtxt(path+'/data/RAA_data_err')\n",
    "# y_exp_variance = np.diag(y_err**2)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a1a4524c",
   "metadata": {},
   "source": [
    "## Reduce parameter dim to 4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "90739bd6",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_max = np.array([1., 1., 0.6, 0.4])\n",
    "test_min = np.array([-0.9, -0.9, 0.16, 0.1])\n",
    "test_ptp = test_max - test_min\n",
    "\n",
    "test_dim = 4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8c0bc6e9",
   "metadata": {},
   "outputs": [],
   "source": [
    "nwalkers = 20*test_dim  # number of MCMC walkers\n",
    "nburn = 1000 # \"burn-in\" period to let chains stabilize\n",
    "nsteps = 5000  # number of MCMC steps to take\n",
    "# filename = data_path(name+\".h5\")\n",
    "\n",
    "\n",
    "#backend = emcee.backends.HDFBackend(filename)\n",
    "starting_guesses = test_min + (test_max - test_min) * np.random.rand(nwalkers, test_dim)\n",
    "\n",
    "#print(starting_guesses)\n",
    "print(\"MCMC sampling using emcee (affine-invariant ensamble sampler) with {0} walkers\".format(nwalkers))\n",
    "with Pool() as pool:\n",
    "    sampler = emcee.EnsembleSampler(nwalkers, test_dim, log_posterior)\n",
    "    print('burn in sampling started')    \n",
    "    pos = sampler.run_mcmc(starting_guesses, nburn, progress=True, store=True)\n",
    "    print(\"Mean acceptance fraction: {0:.3f} (in total {1} steps)\".format(\n",
    "                        np.mean(sampler.acceptance_fraction), nwalkers*nburn))\n",
    "    print('Burn in completed.')\n",
    "    print(\"Now running the samples\")\n",
    "    sampler.run_mcmc(initial_state=None, nsteps=nsteps, progress=True, tune=False)  \n",
    "    print(\"Mean acceptance fraction: {0:.3f} (in total {1} steps)\".format(\n",
    "                        np.mean(sampler.acceptance_fraction), nwalkers*nsteps))\n",
    "        \n",
    "    # discard burn-in points and flatten the walkers; the shape of samples is (nwalkers*nsteps, Xdim)\n",
    "    #samples = backend.get_chain(flat=True, discard=nburn)\n",
    "    samples = sampler.get_chain(flat=True, discard=nburn)\n",
    "\n",
    "# n_samples = len(samples)\n",
    "# samples = np.concatenate((np.array([samples.T[0]]), np.array([samples.T[0]]), np.array([samples.T[1:3]]), np.array([[2 for _ in range(n_samples)]]), np.array([samples.T[3]])), axis=-1)\n",
    "# print(samples.shape)\n",
    "\n",
    "np.savetxt(path+'/data/running_coupling/MCMC_test_samples', samples)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7b668c72",
   "metadata": {},
   "outputs": [],
   "source": [
    "bounds=[(a,b) for (a,b) in zip(test_min,test_max)]\n",
    "parameters0 = optimize.differential_evolution(lambda x: -log_posterior(x), \n",
    "                                    bounds=bounds,\n",
    "                                    tol=1e-9,\n",
    "                                    ).x\n",
    "parameters1 = [np.percentile(it,50) for it in samples.T]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "82457c13",
   "metadata": {},
   "outputs": [],
   "source": [
    "true_values = np.array([0., 0., 0.3, 0.25])\n",
    "# true_values = design[7]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "199e0fe6",
   "metadata": {},
   "outputs": [],
   "source": [
    "ParameterLabels = ['$\\\\beta_\\perp$', '$\\\\beta_\\parallel$', '$T^*$',  '$\\\\alpha^{inel}_{s, hard}$']\n",
    "ranges = np.array([[-0.9, 1], [-0.9, 1], [0.16, 0.6], [0.1, 0.4]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ec608f6b",
   "metadata": {},
   "outputs": [],
   "source": [
    "samples_df = pd.DataFrame(samples, columns=ParameterLabels)\n",
    "g = sns.PairGrid(samples_df.iloc[:,:], corner=True, diag_sharey=False)\n",
    "g.map_lower(sns.histplot, bins=100, color=sns.color_palette()[9])\n",
    "g.map_diag(sns.kdeplot, linewidth=2, shade=True, color=sns.color_palette()[-1])\n",
    "for n in range(test_dim):\n",
    "    ax=g.axes[n][n]\n",
    "    ax.axvline(x=parameters0[n], ls='-', c=sns.color_palette()[9], label='MAP')\n",
    "    # ax.axvline(x=parameters1[n], ls='-', c=sns.color_palette()[0], label='central')\n",
    "    ax.axvline(x=true_values[n], ls='-', c=sns.color_palette()[3], label='Truth')\n",
    "    ax.text(0,0.9,s= f'{parameters0[n]:.2f}', transform=ax.transAxes, color=sns.color_palette()[9], fontsize=12)\n",
    "    # ax.text(0,0.8,s= f'{parameters1[n]:.2f}', transform=ax.transAxes, color=sns.color_palette()[0], fontsize=12)\n",
    "    ax.text(0,0.7,s= f'{true_values[n]:.2f}', transform=ax.transAxes, color=sns.color_palette()[3], fontsize=12)\n",
    "g.axes[2,2].legend(loc='upper right', fontsize=10)\n",
    "for i in range(test_dim):\n",
    "    for j in range(i+1):\n",
    "        g.axes[i,j].set_xlim(*ranges[j])\n",
    "        if i==j:\n",
    "            g.axes[i,j].set_ylim(*ranges[i])\n",
    "            \n",
    "        else:\n",
    "            g.axes[i,j].set_ylim(ymax=0)\n",
    "            g.axes[i,j].axvline(x=parameters0[j], ls='-', c=sns.color_palette()[9])\n",
    "            # g.axes[i,j].axvline(x=parameters1[j], ls='-', c=sns.color_palette()[0])\n",
    "            g.axes[i,j].axvline(x=true_values[j], ls='-', c=sns.color_palette()[3])\n",
    "            g.axes[i,j].axhline(y=parameters0[i], ls='-', c=sns.color_palette()[9])\n",
    "            # g.axes[i,j].axhline(y=parameters1[i], ls='-', c=sns.color_palette()[0])\n",
    "            g.axes[i,j].axhline(y=true_values[i], ls='-', c=sns.color_palette()[3])\n",
    "            g.axes[i,j].scatter(parameters0[j], parameters0[i], color=sns.color_palette()[9])\n",
    "            # g.axes[i,j].scatter(parameters1[j], parameters1[i], color=sns.color_palette()[0])\n",
    "            g.axes[i,j].scatter(true_values[j], true_values[i], color=sns.color_palette()[3])\n",
    "plt.tight_layout()\n",
    "plt.savefig(path+'/plots/running_coupling/Posterior_of_true_parameters_pca4_param4_obs4_dps32')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3130fa27",
   "metadata": {},
   "outputs": [],
   "source": [
    "Nsamples = 100\n",
    "Nthin = samples_df.size//Nsamples\n",
    "# prior parameter samples\n",
    "prior_params = (ranges[:,1]-ranges[:,0])*np.random.rand(Nsamples,test_dim) + ranges[:,0]\n",
    "# posterior parameter samples \n",
    "posterior_params =  samples_df.iloc[::Nthin,:].values\n",
    "prior_params = np.concatenate((np.array([prior_params.T[0]]).T, prior_params.T[1:3].T, np.array([[1.6 for _ in range(Nsamples)]]).T, np.array([prior_params.T[3]]).T), axis=1)\n",
    "posterior_params = np.concatenate((np.array([posterior_params.T[0]]).T, posterior_params.T[1:3].T, np.array([[1.6 for _ in range(len(posterior_params))]]).T, np.array([posterior_params.T[3]]).T), axis=1)\n",
    "\n",
    "prior_obs = []\n",
    "posterior_obs = []\n",
    "\n",
    "for p in prior_params: \n",
    "    A = np.array([predict_observables(p, diag_std=True)])\n",
    "    Y_predicted = A[:,0,:]\n",
    "    # prior_obs = np.array([np.concatenate(Y_predicted)])\n",
    "    prior_obs.append(list(Y_predicted[0]))\n",
    "\n",
    "for p in posterior_params: \n",
    "    A = np.array([predict_observables(p, diag_std=True)])\n",
    "    Y_predicted = A[:,0,:]\n",
    "    posterior_obs.append(list(Y_predicted[0]))\n",
    "    \n",
    "prior_obs = np.array(prior_obs)\n",
    "posterior_obs = np.array(posterior_obs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c0b18237",
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, axes = plt.subplots(2,4, figsize=(16,8))\n",
    "fig.subplots_adjust(hspace=0, wspace=0)\n",
    "CLbins = [95]\n",
    "for isample, ilabel, color in zip([prior_obs, posterior_obs], \n",
    "                               ['prior','posterior'], \n",
    "                               [sns.color_palette()[0], sns.color_palette()[3]]):\n",
    "    for CL, opacity in zip(CLbins, [.35, .3, .25, .2]):\n",
    "        label = '{:d}% {}'.format(CL, ilabel)\n",
    "        lower, upper = np.percentile(isample, [50-CL/2., 50+CL/2.], axis=0)\n",
    "        axes[0, 0].fill_between(pT1, lower[:Nc1], upper[:Nc1], color=color, alpha=opacity, label=label)\n",
    "        axes[0, 1].fill_between(pT2, lower[Nc1:Nc2], upper[Nc1:Nc2], color=color, alpha=opacity, label=label)\n",
    "        axes[0, 2].fill_between(pT3, lower[Nc2:Nc3], upper[Nc2:Nc3], color=color, alpha=opacity, label=label)\n",
    "        axes[0, 3].fill_between(pT4, lower[Nc3:Nc4], upper[Nc3:Nc4], color=color, alpha=opacity, label=label)\n",
    "        axes[1, 0].fill_between(pT1, (lower/y_exp)[:Nc1], (upper/y_exp)[:Nc1], color=color, alpha=opacity, label=label)\n",
    "        axes[1, 1].fill_between(pT2, (lower/y_exp)[Nc1:Nc2], (upper/y_exp)[Nc1:Nc2], color=color, alpha=opacity, label=label)\n",
    "        axes[1, 2].fill_between(pT3, (lower/y_exp)[Nc2:Nc3], (upper/y_exp)[Nc2:Nc3], color=color, alpha=opacity, label=label)\n",
    "        axes[1, 3].fill_between(pT4, (lower/y_exp)[Nc3:Nc4], (upper/y_exp)[Nc3:Nc4], color=color, alpha=opacity, label=label)\n",
    "\n",
    "for i, ax,y,yerr,name, pT in zip(range(4), axes[0], \n",
    "                    [y_exp[:Nc1], y_exp[Nc1:Nc2], y_exp[Nc2:Nc3], y_exp[Nc3:Nc4]], [y_exp_err[:Nc1], y_exp_err[Nc1:Nc2], y_exp_err[Nc2:Nc3], y_exp_err[Nc3:Nc4]], \n",
    "                    [r\"$R_{\\rm AA}$\"]*4, [pT1, pT2, pT3, pT4]):\n",
    "\n",
    "    ax.errorbar(pT, y, yerr=yerr, fmt='k.', label='valid')\n",
    "    if i == 0:\n",
    "        ax.set_ylabel(r\"$R_{\\rm AA}$\")\n",
    "    # ax.set_xlabel(\"pT (GeV)\")\n",
    "\n",
    "for i, ax,y,yerr,name, pT in zip(range(4), axes[1], \n",
    "                    [y_exp[:Nc1], y_exp[Nc1:Nc2], y_exp[Nc2:Nc3], y_exp[Nc3:Nc4]],[y_exp_err[:Nc1], y_exp_err[Nc1:Nc2], y_exp_err[Nc2:Nc3], y_exp_err[Nc3:Nc4]],\n",
    "                    [\"Ratio to data\"]*4, [pT1, pT2, pT3, pT4]):\n",
    "    ax.errorbar(pT, y/y, yerr=yerr/y, fmt='k.', label='valid')\n",
    "    ax.axhline(y=1, ls='-', color='k')\n",
    "    if i == 0: \n",
    "        ax.set_ylabel(\"Ratio to data\")\n",
    "    ax.set_xlabel(\"pT (GeV)\")\n",
    "# axes[0,0].semilogy()\n",
    "# axes[0,1].semilogy()\n",
    "axes[0, 0].set_ylim(0,1.8)\n",
    "axes[0, 1].set_ylim(0,1.8)\n",
    "axes[0, 2].set_ylim(0,1.8)\n",
    "axes[0, 3].set_ylim(0,1.8)\n",
    "axes[1, 0].set_ylim(0,2)\n",
    "axes[1, 1].set_ylim(0,2)\n",
    "axes[1, 2].set_ylim(0,2)\n",
    "axes[1, 3].set_ylim(0,2)\n",
    "axes[0, 0].set_title('Au+Au 200 GeV, 0-10%', fontsize=16)\n",
    "axes[0, 1].set_title('Pb+Pb 2760 GeV, 0-5%', fontsize=16)\n",
    "axes[0, 2].set_title('Au+Au 200 GeV, 20-30%', fontsize=16)\n",
    "axes[0, 3].set_title('Pb+Pb 2760 GeV, 30-40%', fontsize=16)\n",
    "axes[0, 0].legend(prop={'size': 12})\n",
    "axes[0, 1].legend(prop={'size': 12})\n",
    "axes[0, 2].legend(prop={'size': 12})\n",
    "axes[0, 3].legend(prop={'size': 12})\n",
    "axes[0, 1].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[0, 2].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[0, 3].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[1, 1].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[1, 2].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[1, 3].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[0, 0].tick_params(direction=\"in\", which='both')\n",
    "axes[0, 1].tick_params(direction=\"in\", which='both')\n",
    "axes[0, 2].tick_params(direction=\"in\", which='both')\n",
    "axes[0, 3].tick_params(direction=\"in\", which='both')\n",
    "axes[1, 0].tick_params(direction=\"in\", which='both')\n",
    "axes[1, 1].tick_params(direction=\"in\", which='both')\n",
    "axes[1, 2].tick_params(direction=\"in\", which='both')\n",
    "axes[1, 3].tick_params(direction=\"in\", which='both')\n",
    "\n",
    "# plt.legend(loc='upper center', bbox_to_anchor=(0, -0.1), fancybox=True, shadow=True, ncol=3)\n",
    "# plt.tight_layout()\n",
    "plt.savefig(path+\"/plots/running_coupling/Posterior_validation_pca2_param4\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3431961e",
   "metadata": {},
   "source": [
    "# Data analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "20ac99ef",
   "metadata": {},
   "outputs": [],
   "source": [
    "def log_prior(model_parameters):\n",
    "    \"\"\"Evaluvate the prior at model prameter values. \n",
    "    If all parameters are inside bounds function will return 0 otherwise -inf\"\"\"\n",
    "    X = np.array(model_parameters).reshape(1,-1)\n",
    "    lower = np.all(X >= design_min)\n",
    "    upper = np.all(X <= design_max)\n",
    "    if (lower and upper):\n",
    "        lp=0\n",
    "    # lp = np.log(st.beta.pdf(X,5,1,dsgn_min_ut.reshape(1,-1),(dsgn_max_ut-dsgn_min_ut).reshape(1,-1))).sum()\n",
    "    else:\n",
    "        lp = -np.inf\n",
    "    return lp\n",
    "\n",
    "def mvn_loglike(y, cov):\n",
    "    \"\"\"\n",
    "    Evaluate the multivariate-normal log-likelihood for difference vector `y`\n",
    "    and covariance matrix `cov`:\n",
    "\n",
    "        log_p = -1/2*[(y^T).(C^-1).y + log(det(C))] + const.\n",
    "\n",
    "    The likelihood is NOT NORMALIZED, since this does not affect MCMC.  The\n",
    "    normalization const = -n/2*log(2*pi), where n is the dimensionality.\n",
    "\n",
    "    Arguments `y` and `cov` MUST be np.arrays with dtype == float64 and shapes\n",
    "    (n) and (n, n), respectively.  These requirements are NOT CHECKED.\n",
    "\n",
    "    The calculation follows algorithm 2.1 in Rasmussen and Williams (Gaussian\n",
    "    Processes for Machine Learning).\n",
    "\n",
    "    \"\"\"\n",
    "    # Compute the Cholesky decomposition of the covariance.\n",
    "    # Use bare LAPACK function to avoid scipy.linalg wrapper overhead.\n",
    "    L, info = lapack.dpotrf(cov, clean=False)\n",
    "\n",
    "    if info < 0:\n",
    "        raise ValueError(\n",
    "            'lapack dpotrf error: '\n",
    "            'the {}-th argument had an illegal value'.format(-info)\n",
    "        )\n",
    "    elif info < 0:\n",
    "        raise np.linalg.LinAlgError(\n",
    "            'lapack dpotrf error: '\n",
    "            'the leading minor of order {} is not positive definite'\n",
    "            .format(info)\n",
    "        )\n",
    "\n",
    "    # Solve for alpha = cov^-1.y using the Cholesky decomp.\n",
    "    alpha, info = lapack.dpotrs(L, y)\n",
    "\n",
    "    if info != 0:\n",
    "        raise ValueError(\n",
    "            'lapack dpotrs error: '\n",
    "            'the {}-th argument had an illegal value'.format(-info)\n",
    "         )\n",
    "\n",
    "    if np.all(L.diagonal()>0):\n",
    "        return -.5*np.dot(y, alpha) - np.log(L.diagonal()).sum()\n",
    "    else:\n",
    "        return -.5*np.dot(y, alpha) - np.log(np.abs(L.diagonal())).sum()\n",
    "        print(L.diagonal())\n",
    "        raise ValueError(\n",
    "            'L has negative values on diagonal {}'.format(L.diagonal())\n",
    "        )\n",
    "\n",
    "def log_posterior(model_parameters):\n",
    "    \"\"\"\n",
    "    model_parameters = np.array([model_parameters[0], model_parameters[1], model_parameters[2], 2.1, model_parameters[3]])\n",
    "    mn1, var1 = predict_observables(model_parameters)\n",
    "    model_parameter_2 = model_parameters\n",
    "    model_parameter_2[3] *= 1.151589045\n",
    "    mn2, var2 = predict_observables(model_parameter_2)\n",
    "    model_parameter_3 = model_parameters\n",
    "    model_parameter_3[3] *= 0.7194298318\n",
    "    mn3, var3 = predict_observables(model_parameter_3)\n",
    "    model_parameter_4 = model_parameters\n",
    "    model_parameter_4[3] *= 0.8473325979\n",
    "    mn4, var4 = predict_observables(model_parameter_4)\n",
    "    \n",
    "    mn = np.concatenate((mn1[:Nc1], mn2[Nc1:Nc2], mn3[Nc2:Nc3], mn4[Nc3:]))\n",
    "    var = np.concatenate((var1[:Nc1], var2[Nc1:Nc2], var3[Nc2:Nc3], var4[Nc3:]))\n",
    "    \"\"\"\n",
    "    # model_parameters = np.array([model_parameters[0], model_parameters[1], model_parameters[2], 1.8, model_parameters[3]])\n",
    "    mn, var = predict_observables(model_parameters)\n",
    "    delta_y = mn - y_exp\n",
    "    delta_y = delta_y.flatten()   \n",
    "    total_var = var + y_exp_variance\n",
    "    return log_prior(model_parameters) + mvn_loglike(delta_y,total_var)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7b2dce91",
   "metadata": {},
   "outputs": [],
   "source": [
    "y_exp = np.loadtxt(path+'/data/running_coupling/data_exp_4obs')\n",
    "y_exp_err = np.loadtxt(path+'/data/running_coupling/data_exp_err_4obs')\n",
    "y_exp_variance = np.diag(y_exp_err**2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f3d2415d",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_max = np.array([2., 2., 0.6, 2.5, 0.4])\n",
    "test_min = np.array([-0.9, -0.9, 0.16, 1.45, 0.1])\n",
    "test_ptp = test_max - test_min\n",
    "\n",
    "test_dim = 5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "db3be276",
   "metadata": {},
   "outputs": [],
   "source": [
    "nwalkers = 20*test_dim  # number of MCMC walkers\n",
    "nburn = 1000 # \"burn-in\" period to let chains stabilize\n",
    "nsteps = 5000  # number of MCMC steps to take\n",
    "# filename = data_path(name+\".h5\")\n",
    "\n",
    "\n",
    "#backend = emcee.backends.HDFBackend(filename)\n",
    "starting_guesses = test_min + (test_max - test_min) * np.random.rand(nwalkers, test_dim)\n",
    "#print(starting_guesses)\n",
    "print(\"MCMC sampling using emcee (affine-invariant ensamble sampler) with {0} walkers\".format(nwalkers))\n",
    "with Pool() as pool:\n",
    "    sampler = emcee.EnsembleSampler(nwalkers, test_dim, log_posterior)\n",
    "    print('burn in sampling started')    \n",
    "    pos = sampler.run_mcmc(starting_guesses, nburn, progress=True, store=True)\n",
    "    print(\"Mean acceptance fraction: {0:.3f} (in total {1} steps)\".format(\n",
    "                        np.mean(sampler.acceptance_fraction), nwalkers*nburn))\n",
    "    print('Burn in completed.')\n",
    "    print(\"Now running the samples\")\n",
    "    sampler.run_mcmc(initial_state=None, nsteps=nsteps, progress=True, tune=False)  \n",
    "    print(\"Mean acceptance fraction: {0:.3f} (in total {1} steps)\".format(\n",
    "                        np.mean(sampler.acceptance_fraction), nwalkers*nsteps))\n",
    "        \n",
    "    # discard burn-in points and flatten the walkers; the shape of samples is (nwalkers*nsteps, Xdim)\n",
    "    #samples = backend.get_chain(flat=True, discard=nburn)\n",
    "    samples = sampler.get_chain(flat=True, discard=nburn)\n",
    "\n",
    "np.savetxt(path+'/data/running_coupling/MCMC_samples', samples)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e6d5629d",
   "metadata": {},
   "outputs": [],
   "source": [
    "bounds=[(a,b) for (a,b) in zip(test_min,test_max)]\n",
    "parameters0 = optimize.differential_evolution(lambda x: -log_posterior(x), \n",
    "                                    bounds=bounds,\n",
    "                                    tol=1e-9,\n",
    "                                    ).x\n",
    "parameters1 = [np.percentile(it,50) for it in samples.T]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1ca2dee7",
   "metadata": {},
   "outputs": [],
   "source": [
    "print(samples.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c19a4e57",
   "metadata": {},
   "outputs": [],
   "source": [
    "ParameterLabels = ['$\\\\beta_\\perp$', '$\\\\beta_\\parallel$', '$T^*$',  '$Q_0$', '$\\\\alpha^{inel}_{s, hard}$']\n",
    "ranges = np.array([[-0.9, 2], [-0.9, 2], [0.16, 0.6], [1.45, 2.5], [0.1, 0.4]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "169524d2",
   "metadata": {},
   "outputs": [],
   "source": [
    "samples_df = pd.DataFrame(samples, columns=ParameterLabels)\n",
    "plt.rcParams[\"axes.labelsize\"] = 16\n",
    "g = sns.PairGrid(samples_df.iloc[:,:], corner=True, diag_sharey=False)\n",
    "g.map_lower(sns.histplot, bins=100, color=sns.color_palette()[0])\n",
    "g.map_diag(sns.kdeplot, linewidth=2, shade=True, color=sns.color_palette()[0])\n",
    "for n in range(test_dim):\n",
    "    ax=g.axes[n][n]\n",
    "    ax.axvline(x=parameters0[n], ls='-', c=sns.color_palette()[0], label='MAP')\n",
    "    # ax.axvline(x=parameters1[n], ls='-', c=sns.color_palette()[9], label='central')\n",
    "    # ax.axvline(x=true_values[n], ls='-', c=sns.color_palette()[3], label='Truth')\n",
    "    ax.text(0.1,0.7,s= f'{parameters0[n]:.2f}', transform=ax.transAxes, color=sns.color_palette()[0], fontsize=16)\n",
    "    # ax.text(0.1,0.8,s= f'{parameters1[n]:.2f}', transform=ax.transAxes, color=sns.color_palette()[9], fontsize=16)\n",
    "    # ax.text(0,0.8,s= f'{true_values[n]:.2f}', transform=ax.transAxes, color=sns.color_palette()[3], fontsize=12)\n",
    "g.axes[1,1].legend(loc='best', fontsize=11)\n",
    "for i in range(test_dim):\n",
    "    for j in range(i+1):\n",
    "        g.axes[i,j].set_xlim(*ranges[j])\n",
    "        if i==j:\n",
    "            g.axes[i,j].set_ylim(*ranges[i])\n",
    "            \n",
    "        else:\n",
    "            # g.axes[i,j].set_ylim(0, 2)\n",
    "            g.axes[i,j].axvline(x=parameters0[j], ls='-', c=sns.color_palette()[0])\n",
    "            # g.axes[i,j].axvline(x=parameters1[j], ls='-', c=sns.color_palette()[9])\n",
    "            # g.axes[i,j].axvline(x=true_values[j], ls='-', c=sns.color_palette()[3])\n",
    "            g.axes[i,j].axhline(y=parameters0[i], ls='-', c=sns.color_palette()[0])\n",
    "            # g.axes[i,j].axhline(y=parameters1[i], ls='-', c=sns.color_palette()[9])\n",
    "            # g.axes[i,j].axhline(y=true_values[i], ls='-', c=sns.color_palette()[3])\n",
    "            g.axes[i,j].scatter(parameters0[j], parameters0[i], color='red')\n",
    "            # g.axes[i,j].scatter(parameters1[j], parameters1[i], color=sns.color_palette()[9])\n",
    "            # g.axes[i,j].scatter(true_values[j], true_values[i], color=sns.color_palette()[3])\n",
    "plt.tight_layout()\n",
    "plt.savefig(path+'/plots/running_coupling/Posterior_of_parameters_obs4_param5_pc2_dps60')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f0847724",
   "metadata": {},
   "outputs": [],
   "source": [
    "Nsamples = 100\n",
    "Nthin = samples_df.size//Nsamples\n",
    "# prior parameter samples\n",
    "prior_params = (ranges[:,1]-ranges[:,0])*np.random.rand(Nsamples,test_dim) + ranges[:,0]\n",
    "# posterior parameter samples \n",
    "posterior_params =  samples_df.iloc[::Nthin,:].values\n",
    "# prior_params = np.concatenate((np.array([prior_params.T[0]]).T, prior_params.T[1:3].T, np.array([[1.8 for _ in range(Nsamples)]]).T, np.array([prior_params.T[3]]).T), axis=1)\n",
    "# posterior_params = np.concatenate((np.array([posterior_params.T[0]]).T, posterior_params.T[1:3].T, np.array([[1.8 for _ in range(len(posterior_params))]]).T, np.array([posterior_params.T[3]]).T), axis=1)\n",
    "prior_obs = []\n",
    "posterior_obs = []\n",
    "\n",
    "for p in prior_params: \n",
    "    A = np.array([predict_observables(p, diag_std=True)])\n",
    "    Y_predicted = A[:,0,:]\n",
    "    \"\"\"\n",
    "    p2 = p\n",
    "    p2[3] *= 1.151589045\n",
    "    A2 = np.array([predict_observables(p2, diag_std=True)])\n",
    "    Y_predicted2 = A2[:,0,:]\n",
    "    p3 = p\n",
    "    p3[3] *= 0.7194298318\n",
    "    A3 = np.array([predict_observables(p3, diag_std=True)])\n",
    "    Y_predicted3 = A3[:,0,:]\n",
    "    p4 = p\n",
    "    p4[3] *= 0.8473325979\n",
    "    A4 = np.array([predict_observables(p4, diag_std=True)])\n",
    "    Y_predicted4 = A4[:,0,:]\n",
    "    Y_predicted_ = np.concatenate((Y_predicted[0][:Nc1], Y_predicted2[0][Nc1:Nc2], Y_predicted3[0][Nc2:Nc3], Y_predicted4[0][Nc3:]))\n",
    "    \"\"\"\n",
    "    prior_obs.append(list(Y_predicted[0]))\n",
    "\n",
    "for p in posterior_params: \n",
    "    A = np.array([predict_observables(p, diag_std=True)])\n",
    "    Y_predicted = A[:,0,:]\n",
    "    \"\"\"\n",
    "    p2 = p\n",
    "    p2[3] *= 1.151589045\n",
    "    A2 = np.array([predict_observables(p2, diag_std=True)])\n",
    "    Y_predicted2 = A2[:,0,:]\n",
    "    p3 = p\n",
    "    p3[3] *= 0.7194298318\n",
    "    A3 = np.array([predict_observables(p3, diag_std=True)])\n",
    "    Y_predicted3 = A3[:,0,:]\n",
    "    p4 = p\n",
    "    p4[3] *= 0.8473325979\n",
    "    A4 = np.array([predict_observables(p4, diag_std=True)])\n",
    "    Y_predicted4 = A4[:,0,:]\n",
    "    Y_predicted_ = np.concatenate((Y_predicted[0][:Nc1], Y_predicted2[0][Nc1:Nc2], Y_predicted3[0][Nc2:Nc3], Y_predicted4[0][Nc3:]))\n",
    "    \"\"\"\n",
    "    posterior_obs.append(list(Y_predicted[0]))\n",
    "    \n",
    "prior_obs = np.array(prior_obs)\n",
    "posterior_obs = np.array(posterior_obs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d8165678",
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, axes = plt.subplots(2,4, figsize=(16,8))\n",
    "fig.subplots_adjust(hspace=0, wspace=0)\n",
    "CLbins = [95]\n",
    "for isample, ilabel, color in zip([prior_obs, posterior_obs], \n",
    "                               ['prior','posterior'], \n",
    "                               [sns.color_palette()[0], sns.color_palette()[3]]):\n",
    "    for CL, opacity in zip(CLbins, [.35, .3, .25, .2]):\n",
    "        label = '{:d}% {}'.format(CL, ilabel)\n",
    "        lower, upper = np.percentile(isample, [50-CL/2., 50+CL/2.], axis=0)\n",
    "        axes[0, 0].fill_between(pT1, lower[:Nc1], upper[:Nc1], color=color, alpha=opacity, label=label)\n",
    "        axes[0, 1].fill_between(pT2, lower[Nc1:Nc2], upper[Nc1:Nc2], color=color, alpha=opacity, label=label)\n",
    "        axes[0, 2].fill_between(pT3, lower[Nc2:Nc3], upper[Nc2:Nc3], color=color, alpha=opacity, label=label)\n",
    "        axes[0, 3].fill_between(pT4, lower[Nc3:Nc4], upper[Nc3:Nc4], color=color, alpha=opacity, label=label)\n",
    "        axes[1, 0].fill_between(pT1, (lower/y_exp)[:Nc1], (upper/y_exp)[:Nc1], color=color, alpha=opacity, label=label)\n",
    "        axes[1, 1].fill_between(pT2, (lower/y_exp)[Nc1:Nc2], (upper/y_exp)[Nc1:Nc2], color=color, alpha=opacity, label=label)\n",
    "        axes[1, 2].fill_between(pT3, (lower/y_exp)[Nc2:Nc3], (upper/y_exp)[Nc2:Nc3], color=color, alpha=opacity, label=label)\n",
    "        axes[1, 3].fill_between(pT4, (lower/y_exp)[Nc3:Nc4], (upper/y_exp)[Nc3:Nc4], color=color, alpha=opacity, label=label)\n",
    "\n",
    "for i, ax,y,yerr,name, pT in zip(range(4), axes[0], \n",
    "                    [y_exp[:Nc1], y_exp[Nc1:Nc2], y_exp[Nc2:Nc3], y_exp[Nc3:Nc4]], [y_exp_err[:Nc1], y_exp_err[Nc1:Nc2], y_exp_err[Nc2:Nc3], y_exp_err[Nc3:Nc4]], \n",
    "                    [r\"$R_{\\rm AA}$\"]*4, [pT1, pT2, pT3, pT4]):\n",
    "\n",
    "    ax.errorbar(pT, y, yerr=yerr, fmt='k.', label='valid')\n",
    "    if i == 0:\n",
    "        ax.set_ylabel(r\"$R_{\\rm AA}$\")\n",
    "    # ax.set_xlabel(\"pT (GeV)\")\n",
    "\n",
    "for i, ax,y,yerr,name, pT in zip(range(4), axes[1], \n",
    "                    [y_exp[:Nc1], y_exp[Nc1:Nc2], y_exp[Nc2:Nc3], y_exp[Nc3:Nc4]],[y_exp_err[:Nc1], y_exp_err[Nc1:Nc2], y_exp_err[Nc2:Nc3], y_exp_err[Nc3:Nc4]],\n",
    "                    [\"Ratio to data\"]*4, [pT1, pT2, pT3, pT4]):\n",
    "    ax.errorbar(pT, y/y, yerr=yerr/y, fmt='k.', label='valid')\n",
    "    ax.axhline(y=1, ls='-', color='k')\n",
    "    if i == 0: \n",
    "        ax.set_ylabel(\"Ratio to data\")\n",
    "    ax.set_xlabel(\"pT (GeV)\")\n",
    "# axes[0,0].semilogy()\n",
    "# axes[0,1].semilogy()\n",
    "axes[0, 0].set_ylim(0,1.8)\n",
    "axes[0, 1].set_ylim(0,1.8)\n",
    "axes[0, 2].set_ylim(0,1.8)\n",
    "axes[0, 3].set_ylim(0,1.8)\n",
    "axes[1, 0].set_ylim(0,2)\n",
    "axes[1, 1].set_ylim(0,2)\n",
    "axes[1, 2].set_ylim(0,2)\n",
    "axes[1, 3].set_ylim(0,2)\n",
    "axes[0, 0].set_title('Au+Au 200 GeV, 0-10%', fontsize=16)\n",
    "axes[0, 1].set_title('Pb+Pb 2760 GeV, 0-5%', fontsize=16)\n",
    "axes[0, 2].set_title('Au+Au 200 GeV, 20-30%', fontsize=16)\n",
    "axes[0, 3].set_title('Pb+Pb 2760 GeV, 30-40%', fontsize=16)\n",
    "axes[0, 0].legend(prop={'size': 12})\n",
    "axes[0, 1].legend(prop={'size': 12})\n",
    "axes[0, 2].legend(prop={'size': 12})\n",
    "axes[0, 3].legend(prop={'size': 12})\n",
    "axes[0, 1].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[0, 2].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[0, 3].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[1, 1].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[1, 2].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[1, 3].tick_params(axis='y', which='both', labelleft=False)\n",
    "axes[0, 0].tick_params(direction=\"in\", which='both')\n",
    "axes[0, 1].tick_params(direction=\"in\", which='both')\n",
    "axes[0, 2].tick_params(direction=\"in\", which='both')\n",
    "axes[0, 3].tick_params(direction=\"in\", which='both')\n",
    "axes[1, 0].tick_params(direction=\"in\", which='both')\n",
    "axes[1, 1].tick_params(direction=\"in\", which='both')\n",
    "axes[1, 2].tick_params(direction=\"in\", which='both')\n",
    "axes[1, 3].tick_params(direction=\"in\", which='both')\n",
    "\n",
    "# plt.legend(loc='upper center', bbox_to_anchor=(0, -0.1), fancybox=True, shadow=True, ncol=3)\n",
    "# plt.tight_layout()\n",
    "plt.savefig(path+\"/plots/running_coupling/Posterior_pca2_lower1-5_param5_dps60_pc2\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f7712b60",
   "metadata": {},
   "outputs": [],
   "source": [
    "cc = 0.1189\n",
    "Q = 91.1876\n",
    "Lambda = 0.2\n",
    "NC = 3\n",
    "Nf = 3\n",
    "CA = 3\n",
    "c0 = cc / (4*np.pi/9/(np.log((Q/Lambda)**2)))\n",
    "g_const = np.sqrt(4*np.pi*0.3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "26e08adc",
   "metadata": {},
   "outputs": [],
   "source": [
    "CL = 95\n",
    "plt.figure()\n",
    "T_list = np.arange(0.16, 0.6, 0.001)\n",
    "prior_qpara = [[] for _ in range(len(prior_params))]\n",
    "for i, prior in enumerate(prior_params): \n",
    "    beta_perp, beta_para, Tstar, Q0, alpha = prior\n",
    "    qpara = []\n",
    "    for iT in T_list: \n",
    "        c = 4*np.pi/9/(np.log((2*np.pi*max(iT, Tstar)/Lambda)**2)) * c0\n",
    "        g = np.sqrt(4.*np.pi*c)\n",
    "        mD_2 = g**2*iT**2*(NC/3+Nf/6)\n",
    "        Minf_2 = mD_2/2\n",
    "        mu = 4*iT\n",
    "        qhat_QCD = g**2*CA*iT*Minf_2/4/np.pi*np.log(1+(mu/Minf_2)**2)\n",
    "        qpara.append(qhat_QCD*(1+beta_para*(Lambda/iT))/(iT**3))\n",
    "    prior_qpara[i] = qpara\n",
    "lower, upper = np.percentile(prior_qpara, [50-CL/2., 50+CL/2.], axis=0)\n",
    "plt.fill_between(T_list, lower, upper, color=sns.color_palette()[0], alpha=0.35, label='95% prior')\n",
    "\n",
    "posterior_qpara = [[] for _ in range(len(posterior_params))]\n",
    "for i, posterior in enumerate(posterior_params): \n",
    "    beta_perp, beta_para, Tstar, Q0, alpha = posterior\n",
    "    qpara = []\n",
    "    qhat_const = []\n",
    "    for iT in T_list: \n",
    "        c = 4*np.pi/9/(np.log((2*np.pi*max(iT, Tstar)/Lambda)**2)) * c0\n",
    "        g = np.sqrt(4.*np.pi*c)\n",
    "        mD_2 = g**2*iT**2*(NC/3+Nf/6)\n",
    "        Minf_2 = mD_2/2\n",
    "        mu = 4*iT\n",
    "        qhat_QCD = g**2*CA*iT*Minf_2/4/np.pi*np.log(1+(mu/Minf_2)**2)\n",
    "        qpara.append(qhat_QCD*(1+beta_para*(Lambda/iT))/(iT**3))\n",
    "        qhat_const.append(g_const**2*CA*iT*Minf_2/4/np.pi*np.log(1+(mu/Minf_2)**2)/iT**3)\n",
    "    posterior_qpara[i] = qpara\n",
    "lower, upper = np.percentile(posterior_qpara, [50-CL/2., 50+CL/2.], axis=0)\n",
    "central = np.percentile(posterior_qpara, 50, axis=0)\n",
    "plt.fill_between(T_list, lower, upper, color=sns.color_palette()[3], alpha=0.35, label='95% posterior')\n",
    "plt.plot(T_list, np.mean(np.array(posterior_qpara), axis=0), label='mean', color=sns.color_palette()[3])\n",
    "plt.plot(T_list, qhat_const, '--', label='pQCD', color='black')\n",
    "plt.tick_params(direction=\"in\", which='both')\n",
    "plt.xlabel('T (GeV)')\n",
    "plt.ylabel('$\\hat{q}_L / T^3$')\n",
    "plt.legend()\n",
    "plt.xlim(0.16, 0.6)\n",
    "plt.ylim(0, 50)\n",
    "plt.savefig(path+\"/plots/running_coupling/qhat_dependence\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5775215b",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
